Hey everyone, this is Daniel coming up with another long-form conversation. And today my guest is John DeGoz. He's widely recognized in the scholar community for having created the Zio Effect System. And we cover a lot in this very, very dense conversation about good API design, effect systems, of course, but also entertainment, education, future-perving skills in the age of AI, learning, teaching, mentoring, and a lot more. For those of you who don't know, John, in his own work, he's an internationally recognized technologist who serves as CEO of both Ziverge and Goam Cloud. As the executive producer and creator of the upcoming show, The Ultimate Coder, he blends entertainment with hardcore, software engineering to inspire developers worldwide. John created the Open Source Zio Framework for Scala, a widely adopted library that has reshaped functional programming on the JVM. A serial entrepreneur he has founded multiple tech companies and held senior engineering leadership roles across the industry, with decades of experience building innovative software platforms. Here remains deeply involved in the Open Source and functional programming communities as a speaker, writer, and mentor, continually sharing his passion and advancing modern software development. So without further ado, please enjoy a jam-packed, very dense, and wide-ranging conversation with John DeGoz. John, thank you so much for making the time. It's good to see. Thank you for the invitation. It's good to see you again. Alright, so while I was doing my homework for the conversation, I just learned that you are organizing a sort of a programming reality show of sorts. Can you tell us what that's about? Yeah, so it's called The Ultimate Coder. And it's basically a competition between end participants, in this case six. with the goal of figuring out, well, who is The Ultimate Coder? And we wanted to start this one with a theme that would catch people's attention. And AI being all the rage, what we're going to do is we're going to pit five human contestants against one AI contestant. And it's not a typical like, I know this has been done before, like Open AI has entered their AI model. into these programming competitions. It's been done before and the AI is due well. However, we're doing something different. So the types of competitions you see with AI are computer science competitions. Right? They're like lead code style problems, where doing, you know, graph search or some problem that has been solved a billion times over that data is inside the AI is training data. And then the AI has feedback with some sort of test, or framework, as well as maybe compiler errors as to whether or not it's doing the right thing. And obviously AI performs extremely well. Right? Humans, the top human competitors can beat the top AI's right now, but not by much. Yeah. And the average developer when faced with an AI in one of these leaked code style problems would lose. It would take more time. It would make more mistakes. So that's interesting about other people who are doing this. This competition is actually about something that is very near and dear to my heart, which is API design. As functional programmers, I think, you know, we spend a lot of time looking at an API and trying to size it up. Is this a good API? Is it compositional? Is it type safe? Is it ergonomic? And that's driven evolution of ZEO as well as any other open source project I've ever worked on is, what does this library feel like to use? if you were a developer and you're trying to solve some problem in that domain, what does it feel like? And so the question here is if we take five of the best API designers. So, you know, I'm not going to spoil the surprise for you, but there's some pretty interesting candidates here who will be joining the contestant side of things, as well as the judging side of things. And you pit them against an AI and the task is not to implement anything. It's just to come up with that surface area that you see and produce something that is expressive, type safe, and also gives the developer who's using that joy. So, who's going to win? Well, tune in to find out. But I think this is going to be a great way for us to not just educate, right? Because every talk educates all the stuff that I've done at Functional Scala and LambdaConf and a ZEO. and the other conferences I've been a part of, the purpose was education. And yes, there's that here. So, I want interviews with the top API designers in TypeScript. I want them telling you why they made this decision. You know, why they used a union type here, as opposed to a record type or something. I want actually insights to flow from them to everyone else who's trying to learn how to become like them and create highly successful libraries. In any ecosystem that has strong static types. But more than that, I want to entertain. I think people should be excited to see this. And I think that they should have a lot of fun. I think everyone who's participating in the contestants, the judges, and everyone who watches this after the fact should hopefully have a lot of fun. And in combining education with entertainment, so-called edutainment, I hope that this has a much, much, much larger audience than the typical talk these days. And the typical talk, you know, if you're lucky, you get tens of thousands of views in our niche. Right? In some niches, you could get 100,000 views. But in our niche, you're lucky if you get 20,000 views. That's a really successful talk. But what's the cap for something like this? I don't know. But I would hope it would be 10 times higher. Nice. Some directions that we can take this. One thing that make me very curious is how are you going to make the evaluation? How are you selecting candidates and judges and how is the judging performed? Good questions. So I have to be careful what I can spoil and what I can't because we want to save some surprises for the actual event. I can tell you that right now we have a self-nomination form. So you can nominate yourself or you can nominate someone else. And our initial round of candidates to choose from has been created with this form, combined with a few sort of hand picks from people, you know, I know in that ecosystem really, really talented. And I think you could do really well. And we're drawing, basically, we're looking for recommendations right now, nominations for the absolute best TypeScript developers out there. And it does have to be TypeScript specific. And part of the issue here is that we're looking for the best API design. So it would not be fair to compare a Scala API with a TypeScript API with a Haskell API. In fact, I don't even think there are judges who could do that. Right? Because you have to be an expert. You would have to be an expert in all these languages and you have to somehow be able to compare the purely functional Haskell one with the TypeScript one with whatever else you had there. And I just don't think that would work out. So we're specializing it to TypeScript, which means we need TypeScript expertise, which means community nominations go a long way. And then looking at what these people have done in the past and the open source or educational communities and trying to pick the best candidates for the job. So there'll be five contestants, five judges all chosen from the same pool more or less. Some people I think just based on what I know of them and what I've seen of them, naturally make better judges. You know, there's people are very strong opinionated, very well informed and not afraid to give direct feedback. I think that charts you down one course to being a judge. Whereas, you know, a different kind of person who's actually like really a doer and has created some really great stuff is probably a better fit on the candidate side of things. And then the judging will be done by humans. So no AI judge, they will have to judge every single candidate, including the AI. And they'll be judged on three different dimensions, expressiveness. And that's basically a measure of how well this API design does in solving all of the problems in the domain. And an example would be if you're writing a parser library, then expressivity would be able to say, well, can we use this parser library to parse CSV, but could we also use it to parse JavaScript, right, or parse XML. And then type safety, because we are doing this in TypeScript, and TypeScript does have a surprisingly powerful, and I think underrated, type system, like a lot of scalpelers, I know, look down on TypeScript. And they're like, well, trash language, you know, a trash wrapper on a trash language. Not true, man. It's not a doom game at the type level in TypeScript. It's insane. I saw that. That's dedication. Anyway, so type safety, right? And TypeScript actually has, well, it has things that we know about from Scala, like intersection types, and union types, etc. But it has, you know, it's a structural type system as conditional types. It has these very fancy constructs that you can use to do some pretty cool things. So obviously, it has to be TypeScript, and then the final dimension that all the judges will be looking at, which is possibly my favorite, is developer experience. So, how much would you actually like to use this API? When you get excited about this API, and a great example here for those of you who know JavaScript, probably none of your viewers or this old, but there was something XML, HTTP request object, entered by Microsoft to do so-called Ajax calls. And that is one of the worst API designs I have ever seen. You know, that actually made it into production, right? horrendous API design. And that's now replaced in modern browsers. Modern developers don't even know such a thing ever existed. You don't know people had to suffer through that. And now they have fetch. The fetch-based API, which is modern and reasonable and well put together. And the difference from a developer's point of view in using these two different APIs is night and day. It is totally, totally different. And so, what I really want the judges to look at is the joy factor in using an API. And you have to evaluate that with specific problems, right? If we're talking about a parsing library, what does it look like for me to parse CSV? Is that two lines of code? One would expect that parsing something simple should be simple, right? Parsing JavaScript would be harder. And you would expect it to be harder, but you should still have a joyful, delightful experience compared to your alternatives when you go out and you use that API. So I think that's going to be the most maybe subjective part of it. Like, type safety, okay, that's pretty objective. Expressivity is kind of objective. Can you solve all the problems in this domain? Developer experience. I think we could get some judges battling it out there. I certainly hope so. I think it'll make it more entertaining. Why TypeScript out of all languages? Why not things like Scala? Do you want to... Is it because TypeScript is more popular and you want to target a wider audience? Why TypeScript? I think it's mostly to do with the popularity of JavaScript, right? And also TypeScript by extension. I did not want to do the competition in JavaScript because it's dynamically programming. And you would have to kill... You would have to kill Type Safety and you'd be stuck with developer experience and expressivity. And I love types. I love static types. And I think TypeScript is like the same... It's the same person's JavaScript, right? If you really love static typing, then you choose TypeScript. You don't choose JavaScript. And so that pushes me over into the TypeScript side of things. But if you've seen, there's just a lot of, I think, interest in API design and in functional programming from the TypeScript community. And the TypeScript... excuse me, the TypeScript community is just so big compared to the Scala community. And there's so much stuff happening. And it's growing. It's very active. It's very vibrant. There's so many different libraries out there to do so many different things. There's an effect ecosystem, which is important. So you have to TypeScript that has gone its own direction and added really amazing stuff there. And all of that to say, I would love to do this for Scala someday, because I think that would be fun. But you know what Scala is capable of, right? So I know what Scala is capable of. How many people could look at that code and even understand what's going on? If you really took the best Scala API designers and put them, you know, in a room or in a house for two days, you could come up with some amazing stuff. And there would be macros in there. There would be title programming. There would be given. There would be, you know, possibly capability types. Right, who knows what would be in there? The average developer would not be able to understand what's going on. And TypeScript, I think, because there are a lot of people already in that ecosystem. And they're very excited about good API design. And it's adjacent to JavaScript. And the type system is not so foreign that a Java developer can't like have, I don't think a Java developer would have too much trouble understanding the basics of what's going on. The audience is just going to be, I think, much bigger than if I were to do this in Scala. Even though I would love to do one of these in Scala, but it would not be for the audience. It would just be because it would be something that I would like to do a passion project. That's going to be an interesting project, because I've been thinking for a while about this idea of, and you touched upon this a minute earlier, to mix education with the idea of entertainment, to make the... In parting of programming concepts and ideas be fun and easy to watch engaging. So I was wondering how can programming be entertaining? Because in the reason I'm asking this is because... Well, we can touch upon the subject of teaching versus entertainment from multiple English, but the way that I do my materials is from a teaching standpoint. So I create some material illustrating an idea in the simplest way possible. And then I show that I talk while I code and hopefully people get the idea. I mean, I make the occasional joke and I try not to be completely boring and bland, but this idea of entertainment is a little bit foreign to me, at least to my style. So I was wondering what your take is on that, how you can make programming and watching programming, which is just text from the screen basically, be entertaining as entertaining as maybe a video game or e-sports or things like that. Yeah, I think that's a good question and one that we're trying to answer. And we don't have... I think a definitive answer to that. But one is I think emphasizing the human element to programming, right? Because ultimately, there is some drama when it comes to programming. You've got this mountain decline and you might succeed, you might fail. And if you've ever watched someone like code something that's challenging, it can be very interesting to see them go down dead-end paths. And then backtrack can be like, no, that's not working, let's try this something else. Because there's this element of drama, are they actually going to make it? You know, if you add an element of like time pressure to that, it can increase the drama. If you add multiple people, you know, you can make it even more interesting. If you add competing against an AI, if you add, you know, interviews, if you add maybe even some elements of game mechanics, I think each one ups the entertainment factor. And I think that it's my job sort of being the technical person on the production team to make sure that the entertainment does not come at the cost of quality deep sort of hardcore technical education. Because I actually do want people to be able, developers, hardcore developers like you and me, to be able to pause this and say, you know, that was really insightful. I never knew that so much, much went into crafting a really great TypeScript API. But now I know that. And maybe I'm motivated to check out TypeScript. Or maybe I'm just motivated to do a better job in the APIs that I personally designed. And I don't want to sacrifice that. But at the same time, I do want to work on this new type of media that is going to up the entertainment factor by focusing on the human component. The, you know, the drama essentially involved in like a high stakes competition against AI. And try to make it as fun as possible and lighthearted. And I think the reason why I'm so interested in exploring new ideas in the entertainment space. Because AI is changing everything. AI is literally changing everything. I think COVID changed a lot. Like we saw conferences changed after COVID, right? A lot of conferences went out of business. It's hard to get people out of their houses these days. They just want to stay all day. And they don't want to go places and meet real people. And I think it's recovered a little bit since the worst of that. But it's still not back to where it was. There's this definite hesitancy for people to actually get out of their house and travel to somewhere else and meet with people in real life. And that's a shame, I think. But that's COVID. And that's work from home, right? People are in a different mindset than where they were before COVID. But there's other stuff going on. And one of the most interesting and sad things that's happening perhaps is that quality educational content is not getting the same. number of views or the same level of engagement as it used to. And if you think about it, like what is the average... like why did people want to see talks on YouTube back in the day? It's because it's how you learn things, right? You learn new things by looking at what other very experienced, accomplished, successful people have done. And hopefully listening to them teach you and mentor you, which you do on YouTube or going to conferences back before YouTube. And how are developers learning today? Well, in my opinion, they're trying not to learn, right? They're trying not to learn. And that's always a problem because who wants to do more work than necessary. I understand that. But there's a lot of developers out there who just don't they don't want to improve themselves. You know, by asking AI's and asking them for quick solutions. Is that what you mean? Quick solutions, right? AI prompting stack overflow is the old school version of this. But it's like, and I don't want to have to learn about TypeScript Union types or condition. Why would I have ever have to learn about that? How is that relevant to me? I'm just going to ask Claude code to write me add a new endpoint to my code base. Right? They're not really interested. And I think as functional programmers, we've seen this for a long time because like we have a different standard of self improvement. If you're committed to self improvement, then you learn everything about your compiler's type system. You need to know the box in the case of scholarly, you know the bugs, you know how to work around them. You know category theory, right? Or at least abstract algebra. You know all this stuff. And that's a niche audience, super niche. So we understand that. We understand is a hard path to motivating people to actually want to become really good software developers. It's hard. But in the each of AI, it's like almost impossible because people just are not. There's even even the people who are somewhat interested in that before because they saw it could somehow help them in their career. Or now like, well, hey, I can do that. Right? Why would I want to have to do that? I'm just going to ask AI to solve the problem for me. So I think we're entering an era where a lot of developers, even more than before, are just looking for ways to solve their work problems and they're not looking for ways to improve their knowledge of computer science. And so that makes pure education a much harder self. And it's not just that. But like consider how people are learning. Today, if you ask someone a question and they don't have an answer, they will go to an AI and they will ask the AI. Or if they have a question about how to use this library they're using, they go to the AI. That's the first thing. They don't go to YouTube and look for a talk. They go to the AI and say, help me understand this thing. And then they're relying on the AI to have knowledge of that talk on YouTube. So, you know, all of the educators out there are to a greater and greater degree producing content not for humans per se, but for AI. So, they're going to come in and ask. Yeah, and you don't see, I don't think you see that tremendously now, but I see early signs that this is the direction that we're headed in. And in the future, it's going to be the AI watching the video. And the AI won't appreciate our jokes. They want to appreciate our beautiful slides. They want to appreciate, you know, the delivery, the pauses, all of this stuff, the vocal variety. The AI has no appreciation of this. And then they're going to go ahead and build some model of that that's useful to answer a question that a developer has or for a coding agent that actually does the work. But AI is totally changing the nature of education. And it's changing it in ways that I think if you are interested in playing an active role in getting people excited and engaged and helping them learn some new stuff, you've got to be thinking about what's coming over the course of the next five to 10 years. And in my view, it's like... If you are humans, for sure, watching all these fantastic videos on YouTube, even now, like, right? Just look at, like, you can have... in the case of Scala, like Odearsky give a talk, right? And 2,000 people show up to see that, right? And what? 2,000 people? Why? It should be 20,000 people, you know, or 80,000 people watching that, but they're not. Why? They don't need to. And the motivation is gone. And they're just in a different... most developers are in a different mindset now. And they're using AI to educate themselves to the extent they need to. And then they're using AI to solve problems to the extent they're able to. Where do you see this is going with AI and learning good software craftsmanship? Because I've had conversations with, for example, the famous Uncle Bob about the craft of good code. And the thing that I understand from him from his position paraphrasing a little bit is that we're eventually going to get into problems that we've seen before, just like another layer of abstraction. So when the programming industry got to the point where we had compilers, we had a similar sentiment that people would not know how to code well. that the programming craftsmanship as a field of study is going to go down in quality. And the problems that we would see in software produced by higher level languages are going to be very similar to what the programming industry up to that point had already seen. Do you think that's the case as well with AI's? I do think so. I think that there's... Well, there's a whole host of challenges with AI coding agents as they currently exist. They just don't scale over large code bases. They don't scale over large complex problems, especially on the back end. So there's all sorts of challenges I think that we're going to run into. But, you know, one of the themes that you reflected in your question is this sense that all past generations, they feared new technology. And they're like, oh, well, new technology is going to mean we just have a bunch of dummies running the show. And that's going to create new problems. And I feel like yes, probably, or at least people like me are probably falling into that same trap. But I have some awareness of, you know, the pitfalls of thinking skeptically about new technology. So I'm trying to moderate that view and overall in very pro AI. And I do think it is going to completely change the way people build software. And then it's going to lead to new problems, some of which are old problems. And we'll find a way through. And probably like the AI, the Vibe coding generation, which I actually don't think is going to last all that long. Like I don't think in 10 years people will be Vibe coding. We'll have moved past Vibe coding onto something that's more sustainable. But let's just say, Vibe coding were still around in 10 years. The Vibe coders would be lamenting some new technology that's like, you know, going to change everything again from their perspective. So I understand history repeats itself. And we're leery of AI. We know the drawbacks of AI. We don't yet know the solutions. We know there's going to be problems. Based on the past, we know there's going to be problems. But also based on the past, we know people are going to find a way to move up the ladder. They're going to be doing more things, right? I think that's the pattern is one developer right now can do so much. Like let's ignore AI. Let's ignore AI. Think about all of the impact that high-level programming languages with static types in garbage collection and safe concurrency primitives has had on productivity. Or open source, right? Another innovation people thought open source would put commercial software out of business, but it doesn't. It just enables you to build commercial software 100 times faster because 8% of your application is already built. And you only need to build 2% because of all the open source libraries that you're using. So we're moving up the ladder and programmers, I don't know if they'll always be called programmers, right? They might not always be called programmers, but programmers are becoming more and more productive. And AI is just going to enhance and amplify and accelerate that. And you could imagine at some point in the future like five... I mean, I don't want to scare people, but like a 500 person company having all of its technology needs met by having, you know, no. What we think of today as programmers on staff, but like new school programmers, whatever they're going to be called, they might be like, you know, product developers, right? People who combine the ability to work with AI tooling with insight into product and aren't in many ways like managers, right? They're managers of AI agents and AI tooling and coding and they have good sense and they have good high level, good ability to systematize information and knowledge. Small number of those types of people might be able to drive and satisfy the technology needs of an entire 500 person company, which is, you know, good. In the net, right? On the net, it's a good thing for society, for us programmers or our successors to be able to have even more impact than we do today. And we will, you know, programmers of the future will have far more impact than we're able to have now and we have a thousand times more impact. I mean, I think we're a thousand times more productive. If you go back 50 years, we're a thousand times more productive than those programmers. They did everything we've been writing to flat files and whoa, we have all of this tooling, all these frameworks and databases and cloud APIs and static type systems and things they could never imagine. And so we're a thousand times more productive than they are. And in the future, there will be a thousand times more productivity gains than we are probably. And beyond that, I would expect. How do you use AI as they currently stand? Well, I've experimented with the coding agents, like cloud code and whatnot. And I don't think they work well currently for the type of work that I use them for. Or the type of work that I do in open source. So they just don't work all that well and I spend more time trying to fix their mistakes and get them to go down and do the thing that I can do. myself much more efficiently. That said, like I just noticed productivity gains from small things. And an example would be cloud code, it keeps track of the context of your most recent edits. And so it's able to guess what your next edit will be. And you just tap through these things, making minor refactoring changes. And it's not a big thing, but actually it makes me more productive. And it's a very simple way that AI, I think, can be used to enhance the productivity of senior developers who already know what they want to do. They know how they want to do it, etc. They're just using AI purely to enhance to accelerate their performance. Another fantastic way to use AI is for test case generation. Because I hate test cases. Like many programmers, I'm not a fan of test driven development. I understand why there are good reasons for requiring that junior developers build software using TDD. I'm not a fan of it. I want to see the types. I want to see data types. I want to see the interfaces, the traits, the method signatures. I want to understand how everything fits together before I even think about implementation. And so that's the way I work is top down, not bottom up. And so I'm not a fan of TDD. So I always have to add my tests after I've written the software. And it's not fun. And you have to do all the edge cases and you have to do. You have to do a reasonable level of coverage on enough cases that are dissimilar from each other to give you a sense that I'm really good and exercise all of the code paths in the software that I've written. And there's a lot of boilerplate in writing these tests. There's the setup and the tear down and then there's building the examples and then there's writing the assertions to extract out the relevant information and test them. It's mindless software that a monkey or in this case an AI can write for you. And so I'm a huge fan of using AI to help accelerate the development of test suites because it's just something that it doesn't require any deep reasoning novel reasoning in order to do a good job at. And AI is fantastic at that type of thing. Also any type of boilerplate, any type of boilerplate, give it a few examples. And then you can just crank through the boilerplate, like whether it's manually deriving an instance of a type class or writing serialization logic or creating a wrapper on top of another API. All these things are boilerplate heavy. And if you do a few of them, then the AI can pick up on that and it can do a fantastic job of replicating that and making you much more productive and much happier. So those are the ways I'm using AI for coding, but also increasingly I've started using AI for design. So because I don't have time to design everything myself, so I'm trying to experiment with new ways to use AI to come up with designs that are okay. Okay, Ish, you know better, better probably than a junior developer could do, but not at the level that an extremely experienced API designer could create. That's very interesting. That's probably going to give you context for the ultimate coder because if the AI can create nice nice APIs and good design, you also have enough experience to be able to judge it, I guess. That's right. That's right. And it would be helpful to manage this, but it would be nice if in the ultimate coder, like the judge didn't know who they were viewing. Like blinds, blinds, evaluations. Exactly. I don't know if we'll be able to pull that off. There's some challenges involved in making that happen. Plus like people's style does show through. I think to some extent, like you're going to look at an API. And if you know, if you know it had to be one of these five people, you might be able to guess if you're familiar with their work, you might be able to guess who's working it. Right? They have a style. You do. So, I'll see. But anyway, it would be fun if it's a fun idea to contemplate judges looking at the AI's code and thinking a human wrote that and critiquing it like just like an ordinary human's code or vice versa. Maybe they suspect that this person's code was actually the AI. Why? Because there's a comment. Telltale, give away. There's a comment in the code must be AI. Yeah. I was wondering how you see AI as a programming tool. Because I watched a couple of videos of Grady Butch. And he said something along the lines of paraphrasing this, but not by much. He said that throughout the history of programming, the programmer has moved towards an increasing level of abstraction. And that's certainly been the case from machine code to assembly to compile code to cross platform languages and potentially now AI, which is why I'm asking this question. Do you see AI as a potential new abstraction layer or is it something else? How do you how can you speak to that? Yeah. Well, it sort of is just in the sense that you're working at a higher level with an AI. You really are in theory working at the level of English language. You describing requirements. And that is your coding. And then in theory, an AI agent goes off and implements things that satisfy these requirements. However, I think there's another sense in which this is not really abstraction. It's changing the language a bit. Because abstraction really, I think abstraction to me is about looking at a lot of things that are different and finding ways in which they're similar. And an example of the... Yes. You get a linked list. And after squinting, you see, oh, well, a linked list is kind of sort of similar to a map. In the sense that both of them can be viewed as collections. Right. And in the case of a map, it's not a collection of elements. It's a collection of tuples or pairs of elements that can value. That's an example of abstraction where you see things that are seemingly different, but actually there are patterns. And abstraction occurs when you recognize those patterns. And then you start to use them in software. So instead of a function that takes in a linked list or a function that takes in a map, you have a function that takes in a collection of any generic element. That's an example of abstraction. And abstraction allows us to build generic software, which allows us to reduce duplication. And there is, I think, a very real sense in which AIs are not doing that. They're not doing that. It's like, okay, it's kind of a bit like a different programming language, a very bad one. English is a terrible programming language. If you push the current direction further, does that look like humans typing in English or speaking English and having machines completely generate code that the humans don't even understand? What does that look like? That's not abstraction. That's a different programming language. A different ambiguous programming language that whose compiler, if you will, is the AI, which has a non-deterministic translation to machine code, which itself may be non-deterministic, translation to low-level assembly code, et cetera. All the way down, it introduces level of ambiguities, introduces new problems. I don't think it's specifically connected to abstraction, but I do. There is, like, a lot of people use abstraction as, well, we're moving up the tower, right? We're working at higher and higher levels. And yes, working with AI is working at a higher level. For sure. Is it abstraction? Maybe not exactly in the same way that myself and other programmers like me use that term abstraction. Yeah. I asked this question because I've been thinking a lot about whether programming within an AI with prompts can be thought of as true engineering in the sense because when you move up a layer in the abstraction hierarchy, you're still expressing things very specifically and with maximal precision. Whereas you touch upon these ideas, English is ambiguous and has metaphors and has expressions that mean different things in different contexts. So it's not an abstraction in that sense because you have to be extraordinarily precise in how you use words to describe things. And if you mix, if you switch words in the English language, it can mean a completely different thing or the LM might interpret that as a completely different task. That's one. And the non-determinism is the second big component because LM's can produce and do produce different output on the same input if prompted twice. So I wanted to hear your take on that now. Thank you for, thank you for it. I wanted to get back to teaching for a moment because you said earlier that AI is kind of eating the teaching aspect of programming because it makes it very easy for programmers to simply get solutions rather than understand how things work and use and make informed decisions based on that understanding. And I'm wondering how you adapt your own teaching to the appearance of AI. You are a long time teacher and trainer and I wanted to understand how you're changing your teaching style. Yeah, well the answer is I'm not, not significantly anyway. And that's because I'm not teaching for a living so to speak right now. I think there will be a time in the near future, probably six months to nine months when I spend more time doing a form of teaching, basically developer evangelism for some of the stuff that I'm working on for my day job. And at that point, I do need to tackle that question. And everyone does. And one of the really crazy things is like you have these frameworks like effect, but also like convex, which convex is not really a framework. It's more platform, but it has a framework in it. And a lot of them are like, well, we're not just going to have a developer documentation center anymore. We are going to stand up an MCP server that actually uses AI, right, uses some sort of inference underneath the hood in order to be able to implement all the different tools exposed by the MCP server. And that's going to help developers build applications using this SDK, this framework, this platform, this whatever. And also answer their questions. So that's really interesting. Why? Because like, formerly I would be in that role as an educator. There's no MCP server. I'm the one who's teaching you the SDK documentation by focusing on the big picture and driving down into specific use cases and giving you the background information, giving you the code snippets, having a repository to accompany this. It gets you started with quick start examples like I'm the MPC server. And now there's another MCP server out there that can do a better job than me in some ways. It's 24 seven and it scales. And it's probably free. And how do I compete with that? I think that's a very interesting question. And I think there still is a role for educators to be teaching, but also I think educators need to be thinking in terms of like especially if you're in developer evangelism. Right now if you were to start a project like ZM today. Would you be thinking, oh, I need a full time developer evangelists, right? Or I need to spend 40% of my time doing developer evangelism and building a documentation center and writing blog posts and doing videos on YouTube. Or would you think I need to carve out two months where I can build a really nice MCP server that can answer people's questions and that can generate code for them and do other types of things. And I think the answer is you might start with the MCP server and build whatever you need to make that work really well because that's going to have significantly, it's going to have much faster adoption and impact. That's the thing about AI is it accelerates everything. And if you create an MCP server for your framework or library or your programming language or whatever it happens to be, then you can instantly plug that into. One of these general purpose agents and there's no learning process involved. You can actually short circuit the entire learning process. A developer can now say build me an effect application which has four routes in it. You know, and these are the routes and this and it will happen and they will watch that and then they will just go into modify it and tweak that and some fashion. And so it has to impact education and education has to be less about trying to build neural connections. Like that's one of the things that I have done a lot as an educator is I try to reinforce certain neural pathways. And I do that by repetition repetition repetition and then showing lots of different views of the same thing. And also getting people to interact with it and actually go through the process of solving little exercises when I do workshop style teaching, solving exercises. And your point with all this repetition and different views on the same thing and getting people to actually create something using their hands is to build the right neural connections that enable them to be successful in using these technologies. But now they can be successful without those neural connections. So I think the big picture is probably more important and as an educator I'm going to be focusing more on the big picture of things and less on the details that can be done by your coding agent and just try to give people a sense for what this thing can do and at a high level what it looks like when you end up building something. So that they can better determine whether or not they actually want to use this particular tool to solve the problems they have. You're almost in like product market fit territory where you're trying to you're trying to quickly allow a developer to assess whether or not the thing that you're selling which could be an open source library could be a programming language could be. It all is actually going to help them solve it. So you're more big picture and less minutia and less repetition because you don't necessarily need to do that in order to enable the developer to be productive using your technology. That's an interesting take. I've been pondering this idea for a lot of time because most of my time is spent on my learning platform. As you know, I'm creating lots of material to make hard topics easy to understand. And you were very talented by the way. You were very talented in doing this. I think you're one of the best educators that the community has ever seen. That's such a nice compliment. Thank you so much. And I've been pondering this idea of using AI to help people accelerate learning specifically for what they need instead of watching an entire, I don't know, 10, 15 hour course thing. And I, even last year, I created an AI tool that indexes my content and answers questions and stuff. Very, in a very curious way, I saw usage for that tool to be very, very low compared to the videos that I've produced, even though my videos are long form, even though I talk at length about things. And I asked my private community about why that's the case. Why are they not using the AI tool? Because it seemed to get like really good answers. And for a reason that I haven't understood yet, people still prefer structured learning because one of the value, the added value that I produce for the for the audience is shortening that learning time by selecting sequencing and illustrating the clearest examples for the topics at hand. So my job is more in the selection sequencing and streamlining that the sequence of ideas in order for people to understand them much quicker than learning on their own. Obviously, learning on their own is the more effortful path forward and I want to shorten that. And I thought that the AI would shorten that further, but that was not the case. And I've had members of my community say, hey Daniel, if you focus on AI, you're going to lose a customer here. I want your videos and that kind of baffled me. I'm still not sure what to make of that, which is why I asked you this question. I'm still going to ponder this idea and also. So I'm very like encouraged to hear that. And I hear that too, you know, from time to time I hear people say, oh, it's fantastic that you made a talk and you invested all the effort in trying to teach us some, you know, and it certainly is rewarding. And like I have no doubt that they're with all always exists. A subset of people who really want to understand. They're not satisfied with just like getting a quick... they don't want to copy pace from Stack Overflow. They actually want to understand how to answer the question themselves on Stack Overflow. I have such in depth knowledge that they are a master of this topic. And they don't need to copy-paste someone else's answer. I think possibly, first off, that is optimistic and I think that especially for. .. For niche topics and communities, there's always going to be a need. For example, like AI itself, right? They're always be AI engineers who are building the next greatest thing. They need to understand everything about neural networks and reinforcement learning and transformers and all these different things. And so there's always going to be a need for in-depth education on these topics and math and equations and all these other things I think that will be quite helpful. Now, at some point it might be an AI who is like, you might be interacting primarily with a tutor who's tutoring you specifically and asking you questions and drilling you. And trying to reinforce these things so you can become the competent professional who builds the next generation of AI or whatever the domain happens to be. I think what you might be seeing is a little bit of the fact that there's like selection bias, right? If you are... I don't know what you saw this with, but obviously you've done a lot of scholar content and scholar developers they do want to understand. Yeah. This is something that I've certainly noticed. And this is one of the possible explanations why I've received that comment because I've always focused my work towards an audience that doesn't make compromises, which may explain the sort of... I think it's part of it. The average scholar developer they do want to understand and that's fantastic is one of the reasons I like the scholar community is because the people in it, you know, a lot of the people who just wanted the copy paste their answers from Stack Overflow, they stayed with Java or maybe they went to Kotlin or Go Go or something like that. But there's not too many people like that left a scholar community after all these years. There's people mostly gone away to other programming languages. So you might be seeing some of that. And then also I think there's another aspect here, which is that AI is just not that good. In the grand scheme of things, it's not great. And so people still find themselves in a position where they asked their agent to do something and it fails and they still need to understand enough. In order to be able to diagnose and fix the problem themselves. And I think that this is great for educational content because it increases the demand. Is it permanent though? Is it the case that this situation where AI is basically terrible on a wide class of problems, is that going to be indefinite? Or in 10 years will we be in an era where you can really ask your AI agent to do something and it will almost certainly do it in exactly the way that you wanted it to be done. And no one really knows the answer that. I personally believe that we're going to have to go beyond these large language models and develop some machinery that's capable of reasoning using generic models. And I think a lot of people are also in that camp. But no one knows the time horizon. First off, even if that's right, no one knows the time horizon in which that sort of technology can be developed and commercialized. And so it might need the case that 10 years from now. People are not learning things anymore because they have to diagnose and fix things that their terrible dumb AI agents have coded. And in that case, like, okay, well, it's going to have a bigger impact on education. What skills do you think are going to be relevant for programmers to still be effective in the age of AI and not be superseded or replaced? That's a great question. I think that, first off, right now, deep domain expertise is still valuable. It's still commercially valid. And that doesn't mean it's valuable for every position because if you're a front-end developer who's basically standing up new, you know, react interfaces every other week, right? You probably don't need super deep domain expertise and it is quite likely that an AI can do a lot of that for you or in place of you. However, there are still so many different domains where that knowledge of every single quirk of your compiler type system or this backend library versus that backend library or how everything works is going to help you. I'm not just build solutions that AI's can't and keep in mind that in this day and age, AI's cannot in general solve an arbitrary problem in an existing code base. It's just impossible. I've tried many people have tried. They're just not there yet. So all of this deep domain expertise is going to help you tremendously. But then also for reviewing understanding and fixing all the crap that's being generated by AI, all of this knowledge helps. And this is an example where I've had people tell me that AI code that is generated by their coding agent is so much better than anything they could ever do by themselves. I'm like, oh my goodness. Because that's telling me anything that I don't know about AI. That's telling me about where they are. And okay, well, they are like junior level. I would never anyone who thinks AI is generating better code than you. You can generate that junior level. You've just not seen really good code yet. And you don't understand how to evaluate AI code. So I think for now, there's still a huge amount of value in possessing this really deep expertise because there's more clueless people than ever writing code. They don't have any understanding of what's going on. And people who used to job hop every three months because they would be found out for having no coding skills can probably survive longer in an AI age of AI. They can last 12 months at their current position. Maybe indefinitely depending on the company and the standards they expect. But ultimately, there's tremendous demand for people who really know their stuff and can prove that to an employer. So in my view, it's too soon to say ditch the computer science, ditch the type theory, ditch all of these, ditch the concurrency. Don't ditch any of that knowledge now. Double down on yourself, invest in yourself, because it's still valuable. And I think that that is the message for at least the next few years. Until when enough if sort of denovo reasoning becomes a thing in AI, you are going to be at a big competitive advantage by knowing things deeply, especially because you're going to stand out. All of these, you know, vibe coders, you're going to stand way out because you're actually going to know what's going on. And they're going to ask their AI what's going on. And then they're going to regurgate that answer to you. So it's not too soon to stop investing in your own personal knowledge. You know, you should be watching videos on YouTube. You should be attending conference. You should be doing all of these things because it's just going to make sure that you're much more valuable than the typical vibe coder. But also, the world is changing and we all have to acknowledge and recognize that. And we all need to find ways to incorporate AI into our workflows so that we can become more productive. And for me personally, it's like finding ways that I can use AI that are not going to compromise the quality of the end product. Or we'll only compromise it in cases where it doesn't really matter. And I personally have seen like, I don't like to ask an AI to do any coding for me because it's a disaster and I will spend more time rewriting it than I will. I can relate. But, you know, for me personally, like I said before, like AI test cases, why would you not do that, right? I have generated a thousand lines of test cases in this span of probably about 10 minutes, right? And it would take me longer to write those a lot longer to write all of it. And I would not be happy writing. I would be making excuses for why it's time for a coffee break because I hate writing these boilerplatey test cases. They're so low level. So, you know, find test case generation refactoring. They're really great to like, if you need a RegX to match against a certain kind of stuff like that, they're just amazing and they're going to make you much more productive. And they're how we get an edge, right? We have an edge over the five coders because we understand everything top to bottom and left to right. And you can give us any problem. If you're a senior software engineer who's worked in industry for a long time, he worked on large code bases, small code bases, you worked on cloud and non-cloud. You've used all these different programming languages like you're in a really good position. You can make a lot of money and you are highly valuable. But we'd all face direct competition from the vibe coder. They're not going to take our job, right? Because the vibe coders are interchangeable. They function as a layer of insulation between management, project management, product management, and the machine. And there is a place for them. We don't compete with them, but we do compete with other highly senior software engineers. And I always say, like, there's a killer order in every company, which is like, you know, rank of all the engineers, which ones do I lay off first when there's a crunch, right? Which ones do I have to lay off first when there's a crunch? And you always want to be on the bottom of that list. I'm not saying that you should be adversarial to your co-workers, you should not. You should be collaborative, and you're all on the same team. But also, if you do care about job security, especially in tight markets, especially with evolving AI technology, then you always want to be the last person on the kill list. Which means you always need to be optimizing for your own personal productivity. Not just team productivity, which of course is a good metric to optimize for. And good managers will see and recognize that. But you also want to be optimizing for your own personal productivity and personal impact on the team. And not just those things, but the visibility that management has into your personal productivity. And one of the ways you do that in an age of AI is finding ways to use AI to become significantly more productive without impacting the quality of your work. And that means finding these hacks, if you want to call them that for test case generation, documentation generation. Things that people are not going to notice if it's not 100%, exactly the same as you would code by hand, because it honestly doesn't matter all that much. While not compromising the quality of the more intricate work like you fix, you find a bug right that only reproduces in production in concurrent scenarios. It's a race condition. AI is never going to solve that problem. You can solve it. You can bring that to the table. But you can also use AI to become much more productive. And then the final thing I would say is, I think it's time for senior software developers to exercise their business skills or their business hat. You know, we all wear different hats. And I think that it's a good idea for super senior software developers who are starting to use AI tools to start thinking about changes from a higher level perspective impact on users, impact on customers, impact on business. Don't think just in terms of technology. And I would say all very senior software engineers already do this, because it just helps make you more valuable. Like the most valuable person on your team is not just thinking about, oh, I want to use this cool new feature name tuples or whatever it is. They're thinking about whether or not the return on investment is there from the perspective of the business. So if you don't already, if you have not already cultivated these skills and put on your business hat and start thinking about this from the perspective of a product owner or a product developer project manager even, or maybe an end user and be making decisions based on what's going to optimize the company's return on investment, because that's never going to change. A lot of details about how we do stuff might change, but ultimately every business wants to return on investment. They want to put one dollar in here and get two dollars out here. And that involves sometimes making decisions that are not the decisions that we want to make as software engineers. And we have to make compromises. We have to cut corners. We have to think about things differently, not in terms of the shininess of the technology or these two edges fitting together perfectly. We have to think about things from the perspective of the end user and the business. And that type of thinking is only going to become more and more valuable, especially if you want to think about every developer as becoming a manager. And I think that that's a good... it's a good mental model. I'm not saying it's literally going to happen in the way that you would expect those words to come true, but I think it will happen in some way. And in some way every single person is going to become a manager because they will be using AI tools that understand at least something of what they're saying and are capable of doing things for them to some degree. So we're all becoming managers. So thinking about things like a business person is only going to help you thrive in the next era. And we're not there yet, but we're making progress towards the next era. In the next era, if you can think about things like a business person, it's only going to help you. This is an interesting take because I have friends working at the big fan companies, like the Googles and the Metas and the companies like that. And I often hear complaints from them that their performance review always includes this sort of metrics that you mentioned, which is business impact, number of users. I don't know retention or whatever the business seems to be targeting. And it's always a burden for them to justify their work in terms of those metrics that have nothing to do with the code or the tech that they believe they were hired for. But as they grow and as they become more senior, they start to see the value of that and the value of showcasing their work in terms of business outcomes and that sort of thing. The flip side to that is from a business owner perspective, such rock star engineers that start to learn or start to develop their business hat, go on and leave to build startups and their own companies and their own products and that sort of thing. So my question to you is, and as a business owner, I'm pretty sure you've seen this sort of phenomenon happening with your own employees or collaborators. How do you retain people and how do you motivate them to stay with you instead of having them build their own products, their own startups and stuff? Yeah, well, I'm split a bit on that because on the one hand, don't you want people to go out and build their own thing? Like, it's actually pretty exciting when a developer that I've employed gets an idea for startup and decides to leave my company and go out and do that. Why? Because it's like, okay, you inspire them in some way, right? You inspired them and they felt like they got enough of what they needed enough of the inside perspective on how startups are run and how products are built that they decided they could go out and try this thing on their own. And also, I am an educator. I love teaching people and I love mentoring people and I love helping them get off the ground. So even if it is painful and it has sometimes been painful, there's always been a part of me that's really excited when someone decides to do that. And I'm like, good luck. I wish you the best. If you want my feedback or you want to call me I'm here, right? Because it's just exciting to see people do that. So, but that's my perspective as an individual and not necessarily as a company. As a company you need to be thinking in terms of retention, people around. And I think that people have to be thinking in terms of aligning incentives appropriately. If we're entering an era where the cost of creation is lower than it's ever been before. And I don't mean just in software but in any sort of information product. Software is an information product but also movies, right? And music, information products. And you can probably guess from things like VO3 that we are rapidly approaching an era where you and I could probably make a video. We could probably make a movie for cartoon or anime or something. If we wanted to, that's really interesting. The same thing is going to happen in software, right? Where pretty much anyone is going to be able to create some software that does some very impressive things without being able to without having the same expertise and knowledge and skill sets that we would have or that we have in order to create the same things five years ago. So everyone can be a creator. And because of that, it's easier than ever for developers to leave our companies and go off and build their own crazy, cool stuff. And while the individual part of me is like, well, that's great for them and I'm actually really excited about them. I want to see them succeed. As companies, we don't want that to happen. And we need to be thinking in terms, well, why? Why do they want to go off and do this on their own? And there's a few reasons. One is they've seen all the dysfunction inside our organization and are fed up with it. And I think you see that a lot at engineers who work for Facebook and Microsoft and Google, they just see this dysfunction at every level. A lot of it is management dysfunction, right? It ultimately, there are managers who are responsible leading all the way up to the top for the dysfunction that they're seen. And incompetence and incompetence happens. Ultimately, you trace that to the top as well, but incompetence happens because people are hired for roles that they're not fit for and no one has the ability or willingness or maybe even desire to deal with those problems in the way they need to be dealt with. And I think the fact that people can leave your company at any point in time and go create something that might even compete with what they're doing, right? It is going to force people to do a better job aligning incentives. And the top thing that I would start with is fixing the dysfunction inside your organization. Make it so they're not looking for a reason to leave. When developers see that they spend all this time working on stuff that has no impact or they don't even get... they don't actually have any information on the impact that their change had for a customer. It's just total disconnect, right? Those are problems of dysfunction. Or when they see projects being thrown away, like companies spending 12 months on something and then they throw it away because they changed their mind because there was a new manager. All of these examples of organizational dysfunction, they act as drivers for your top talent. The people who really know what's what and they're very competent, they're very skilled. They act as drivers of them out of the organization. They push them out. In many cases they push them to other fan companies, but in some cases they, like you say, they go off and they build stuff. Really interesting fun stuff. So I think dealing with organizational dysfunction is a top one. And then also aligning incentives appropriately. And some companies do a good job with this, like restrict and stock units. And you actually make a fair amount in compensation that way. But I think there's always room for improvement there. And I think companies might have to become a lot more equitable. I think the days of issuing every employee 0.00001% stock options that vast over four years might be coming to an end. If every individual can, by using AI, create amazing things on their own. They might force companies to be like, oh, well, they might not need us as much as we need them. And we might have to realign our compensation package so that if we succeed, when we succeed, because of them, they are also rewarded in that. And it's not just us and our shareholders who are seeing the value, it's the employees who are doing the work. And then beyond that, it's like all the standard things. I think those are the top things. Fix your dysfunction and make sure employees benefit financially from the financial success of the organization. And then beyond that, it's all the standard things around, do people feel like they are aligned with the values of your company? Do you have a strong culture? Are you doing something that matters? Are they each empowered to play some significant role in that mission of the company? Or are the people who are working their jerks? Or are they not jerks? Are they really great people who are just interested in seeing the company succeed, no ego environment? There's so many things that go into like quality and what? Which they should already be optimizing for, but aren't substantially different than the age of AI, I don't think. How do you... I wanted to ask you about your entrepreneurial experience because you've built companies. You have a few things rolling like Xivurj and Golden and including your open source work. You're also conference organizer, conference speaker and so on and so forth. How do you balance all of those? Well, one thing is I look for synergies in the different projects that I'm involved in. Because it's like I used to mentor people as part of this Patreon thing that I did and I would always encourage them to find a way to multiply their efforts. You want the leverage. You want to be able to do one thing and translate that into a whole host of benefits. And a great example is building an open source library. Why is that a great example of leverage? Because you build an open source library, you produce something of value that you give to others. Other people receive that and they use it in their software. And every company who uses your open source software will now hire you. Why? Because they know the guy who wrote a piece of critical infrastructure that their application depends on. So writing that piece of open source software, it's not only going to be useful for your own personal learning because you're going to learn a new domain. You're going to learn what goes into creating ergonomic software that developers actually want to use. You'll learn about writing documentation, about getting CI buildings passing. You're going to be investing into yourself with that open source library. But then you then automatically get a free employment card for any company who uses that open source software. Which is fantastic. And it doesn't stop there. You shouldn't stop there. If you build an open source library, then definitely get as many companies using it as possible. So that can lead to your next job. Because you really want to be going to one of them and saying, hey, I want a job here. And they say, well, yes, of course, you can come work for us. And there's people like that like in the Zio community who if they come to me and say, I want a job, I'll be like, done, you're higher. I'll hire you tomorrow. You know, I'll hire you at this company or I'll hire you at any future company that I've done. Why? Because I know you. I've seen your work. I've worked side by side with you. Obviously, I'm going to hire you. Your work is fantastic. And that's not going to... it doesn't have an expiration date. I'll hire them at any company that I work for. Yeah. So that type of relationship is extraordinarily valuable for you personally. But don't stop there. Turn that into a blog post that you publish on LinkedIn. Turn it into a talk that you give a scholar days. Right. Turn it into a MCP server. That helps people build a turn that one thing that you did that one library. Turn it into many different things. Because it's not that much effort. Once you build the library, it's not that much effort for you as an expert to write a blog post or to give a talk or whatever. So it's like incremental amount of work for a significant increase in the amount of leverage that that work product is giving you. And it's the same way there are synergies between all the different efforts that I'm doing. Like, for example, functional scald. Right. A conference dedicated the scald programming language, which also indirectly served to amplify the Zio ecosystem. But also Ziverge's role in helping companies succeed with scald in beyond. Right. So it was marketing and branding for Ziverge, the consultancy, as well as an opportunity to introduce a bunch more talks in Zia. And then we weren't Zio exclusive. Right. There's lots of talks and type all this stuff and hockey stuff and whatnot. But it certainly was an opportunity for us to get a lot of Zio talks out there and get them recorded and put on YouTube. We're now AI's are scanning and be fed back into answers that developers are asking. It's about leverage and synergy. And a lot of the things that I'm doing now, like the ultimate coder. That is definitely an entertainment and I really hope people learn a lot about that. But also the more reach that has, obviously Ziverge is designing this AI agent. And so whether the AI agent does well and beats the humans or does not do all that well, I mean, it's going to do reasonably well because that would be my guess. But we don't know for sure if it's going to beat the humans. No matter what though, it's a huge amount of exposure for Ziverge in the context of AI. So now people see Ziverge building these AI agents which are taking on humans, right? And maybe not winning but still producing really amazing stuff. And so that's good for Ziverge and it's good to expand our offerings to include AI specific offerings. And there's a tie-in with Golden Cloud as well and all the other stuff I'm doing. It's all connected. It's all related. So it might seem like they're totally different and independent, but actually they're part of one overarching story. And when one part does well, it affects all the other ones it's connected to. And so that minimizes the amount of effort. Like for me, it's not really doing five independent projects. It's doing really one project that happens to manifest itself in a lot of these different ways. And I think that's a similar story if you've looked at like Elon Musk. And the way, yeah, he's CEO of however many companies he is. But they all tie together in various ways. Right there. And in fact like one of them just acquired another one. There's all synergy between all the things that he's doing and they tie together in very well ways. And his one story is I think it's humans on Mars, right? Or something like that is interplanetary human species. And everything ties together into that arc. And it's... and you see it in different companies and different initiatives. But fundamentally there's one story there that is manifesting itself in different ways. And the same for all of the different initiatives that I am involved with right now, there really is one story. Behind all of them. It's a very interesting take that you have multiple projects that feed into one another and get energy and leverage from one another. That's something that I'm going to steal for my upcoming projects. And I think it's a good way to pick next projects. That's right. Because some of the people I've mentored were like, well, I'm going to do this thing and I'm going to do this thing. And this thing I'm like, there's no connection between any of them. So what that means is okay, like your odds of success start from zero with every new project, right? So if you have synergy, if you have leverage, if a success over here ripples down and helps these other succeed, then it just amplifies your six... it amplifies your chance of achieving success rather than detracting from it. So if all of your projects are connected in some way, it does give you leverage, then you're more likely to succeed. I think then if they're totally disconnected. Very cool. I am going to steal this idea. Please do. And it's very interesting that from the ecosystem of the things that you do that you're involved with, the first thing that you started with was open source. I find that very interesting. And I wanted to ask you about open source and the development of the zero, of course. And specifically, I mean, there are many, many avenues that we can take on this one. I wanted to ask if you had difficult moments in the development of zero as the open source project. And I'm asking this first from the technical standpoint. If there are any particularly difficult things that you encountered while developing zero. A bit of context about that. One of the reasons why I'm asking this is because when people look at something like zero, they see a very nice type of safe API. They see guarantees. They see composition. They see Lego bricks. But they don't see the complexity under the hood. And one of the reasons why I'm asking this question of what a difficult technical bit of zero implementation was is for people to understand and appreciate the complexity of such a thing. Yeah, I think that's a great question. And I would say that, well, first off, what is the goal of any functional library that I design? It is to provide that experience of building your application with Lego-like building works. It all fit together well. And what I'm aiming for is a level of conciseness. Like personally, when I'm doing functional programming, I accept there's going to be boilerplate inherent to the functional paradigm. And that's the whole debate of direct style versus effect systems. Effect systems, they add a certain amount of boilerplate and they require you think in a DSL that is written in the host language, rather than thinking just purely in terms of the host language constructs for imperative programming. That is a notable drawback. And it's potentially why effect systems will never be mainstream. But nonetheless, when doing things functionally, I accept that as a limitation of the domain, because it comes with certain perks that you can't replicate otherwise. There's no way to get these perks otherwise. algebraic effect systems, unless you have language level supports, can't really get some of these perks. I mean, they can't. So you have to embrace the functional paradigm. If you do and you accept the cost, then you can really achieve, I think, tremendous power, tremendous expressive power. And that's one of the goals of API design is to achieve an enormous level of power in a small number of lines of code. With pieces fitting together so precisely that you have some confidence that your application is going to run in production without ever having run it. You don't even run the task and you just know that it's going to work. And that's an amazing experience. And it appeals to the functional programmer, the mathematician in me, whatever you want to say. And it appeals to a lot of other people in my same circles. We all like static types. We all like math. We like category theory. We like type safe design. We don't like writing tests. We just want to run software and have it work. We wanted to be correct by construction, so to speak. So I'm looking for that in any design that I come up with. And in order to achieve that, sometimes you have to, especially at these ugly low level, real world imperative domains. And an example would be a synchronicity and concurrency and errors of all kinds, both expected and unexpected. And just sort of underlying limitations of the JVM platform in order to achieve those design goals on top of this mess. A synchronicity is a giant mess, concurrency, giant mess, errors, giant math. All of these areas are super messy and they're fraught with all sorts of complexity and problems and edge cases. And in order to achieve my goals for that API, which is clean, Lego-like building blocks that give joy to a developer where you build something and you know it's going to work. Sometimes the implementation has to be outrageously complex. Outrageously complex. And this is something I have known and appreciated for quite some time. And I used to encourage developers, this was probably 15 years ago, and like, look, I know, because I've worked on some big code bases and big code bases, you have like parts of your code base, which are only used by other parts of the code base. It's like you have a platform team inside Facebook and Microsoft. You have platform teams for any project. They build software for other developers. They work on... it's that common module that eventually grows to be its own sort of way of building software inside the organization. Everyone's using that. And I typically work with those teams, the platform teams. And I'm like, okay, well, I know it would be harder for you to do this. But the reality is we've got, you know, 100 engineers using this API and they're all making the same mistake. We need to change this so they can no longer make that mistake. And they're like, it's going to be too hard. It's going to require 2000 lines of code. And it's only going to save them 10 lines of code, right? You're going to have to do 10,000 lines of code or maybe just a thousand to save a developer 10 lines of code. How does that trade off make sense? Well, it absolutely does make sense because of scale. So if we have 100 or 1000 engineers, each one saving 10, you know, a thousand lines of code. And that's tremendous savings. Even if you personally have to suffer. And that's my perspective on library design, which it doesn't matter how much a library designer suffers. So long as it relieves pain in a significant enough number of end users of that library. So you eat the pain, you know, you eat the pain. And you eat the pain, even if it's absurd and insane, you still eat the pain. Why? Because if you save every developer one line of code because you have 1 million developers using this library, you've saved a million lines of code being written. That makes sense. That trade off makes sense. So that's my philosophy with Zio. And these other libraries is that it doesn't matter how much pain we have to go through. We ultimately want this clean Lego-like, type-safe, joyful experience for developers that's going to help them write correct software. Even software that's really beyond them to advance, right? If you think about some of the concurrency stuff you can build using software transactional memory. Or even just like safely using async concurrent queues without having to deeply think about all the stuff that's going on underneath the hood. There's a lot of stuff there. And it's true for Zio. It's true for all the open source that I've worked on that you see the tip of the iceberg. And underneath the water is this huge, big, gigantic mess, fold filled with very complicated scenarios and edge cases and low-level realities that you have to deal with. And it's worth it, in my opinion. But it doesn't make it easy. And there have been several points over the development of Zio and related parts of the Zio ecosystem. Where the internal complexity reached a breaking point. Things were getting too complex to keep inside my mind anymore. Or in the mind of any developer, right? So I didn't write all of Zio. For example, Zio streams has had a number of different authors. And I remember the points at which it passed some sort of threshold. And now it was too big, too complicated to keep inside all of these different constraints. And the full picture of the implementation story, how everything was working, too big to keep inside my mind or anyone else's mind. And that's challenging. It's very, very challenging. And that actually led to a few rewrites. Where we're like, okay, well, we've crossed the threshold. And it's too complicated for us to understand the city more. And you don't necessarily have to do that. By the way, we didn't always do that. We survived with these ridiculously complex implementations for some period of time. And even to some extent now are surviving with them in certain areas of the Zio ecosystem. But how this manifests itself as bugs. When you have something that's too big to fit in your mind, you can no longer say, I know this is correct. This isn't true for Zio. I can now fit all of the implementation of Zio in my head. But there were versions, predecessors of the current internal runtime engine of Zio. I couldn't fit in my head. I had no idea if it was correct. You know, I had some parts were obviously correct. We have a really great test suite that just keeps on being added to over the course of many, many years. But there were versions of Zio were like, I don't know. I anymore. This looks somewhat suspect. But I can't say one way or the other if this code is correct. And it manifests itself in bugs. So when you have code that doesn't fit inside your head that you can't just look at and know is correct, then you have all these bugs because people see the surface area and they fit together like Lego building blocks. Sometimes they stack this block on top of this block and they expect it to line up perfectly. But it's, you know, it's off to the side and ends up collapsing. And so you get a bug report and the bug report makes no sense. Like what? What's going on here? This isn't what I would predict to happen based on the public Zio API. And that's because your abstraction has an imperfect implementation. There's some bug in some lower level. And it might not be obvious where that is. These tend to be very tricky bugs. And there's been tons of cases of that over the history of Zio and related libraries just went like things got too complex. It led to end user bugs that were very difficult to track down and fix. And I would even say that currently Zio streams is a bit like that. It's just very complex code based and no one truly understands everything inside Zio streams anymore. It was written by too many developers and you have to really study some of these methods. Like I go back to semaphore being used to do limiting of concurrency, streams level parallelism and just all the weird constructs being used here. Like, okay, well, if I spend 30 minutes, I can reasonably understand how this code is working. But it takes a lot of time for someone who is involved in writing this code to just understand. And still, I can't always convince myself that it's correct. So Zio streams is a bit too complicated for its own good. But the top level, the developer experience is nice. It's just the life, the experience of maintaining this library is not the best because it's very complicated. Well, we certainly appreciate the pain that you and the rest of the Zio contributors have eaten over all these years for us to get a good programming experience. And the kind of Lego bricks that we can now build our software with. You said something earlier about effects systems never becoming mainstream. And that caught my attention because effects systems are popping up. Even Scala has to establish effects systems and a new one. The key one is just about to turn 1.0. So we have three effects systems with their own DSLs and with their own APIs. Plus the skull language itself adding capabilities and somewhat overlapping with the point of effects. They're programming languages that are focused on effects like flicks and effect. And there is the effect TypeScript, the effect TS library that is absolutely fantastic. I've personally used it in one of my projects. So what's your take on this effect system proliferation? So I think first off, you have to look at what's driving this. And in some cases, pains are driving it. For example, in TypeScript, it's a pain to deal with async programming, especially in the presence of concurrency and errors. And the APIs obviously have async await, which helps in JavaScript. But to also have a fundamentally broken primitive here, which is promises. Promises are broken. They're broken by design. They were not designed by people who had deep expertise in designing asynchronous libraries. And so there's a lot of serious drawbacks that are never going to be rectified because it's codified as a standard now. It's baked in. So if you want a reasonable way to do asynchronous concurrent programming in JavaScript, you're already looking at libraries. You need a library. And so that allows an effect system, effect systems are very good at dealing with asynchronously and concurrency. It allows an effect system to take advantage of the amount of pain that developers are actually in. And if it's lightweight enough, then many people would judge the benefits to be worth the cost involved. However, I think outside of the area of asynchronously and concurrency, which are, I think, maybe not unique to JavaScript, but certainly hyper-exaggerated in JavaScript and also baked into the language currently via promise and async await, look at the random language, like Java, the latest version of Java, which you have loom, you have virtual threads, you have all this really great stuff for doing concurrency that is very familiar to developers. And you have to answer the question, what problem or set of problems is an effect system going to solve? And, you know, there are problems that they do solve. Like for example, I can look at a type signature for a method and I can know what this method is doing. I know if it's going to do mutation, global mutation or local mutation. I know if it's going to be using the console or I know if it's going to be throwing errors, etc. by looking at a signature with an effect in it, you mean? Yes, okay, yes. And there's some value for me as a developer, right, understanding that. But that's... it's more or less, I wrote a blog post some time ago about this. And basically I consider fine-grain effects to be an anti-pattern in the sense that the problems that it solves are more or less documentation and tooling issues. You're piggybacking documentation and tooling issues on the compiler and you're allowing the compiler to reflect what could be solved by better tools and better documentation. Maybe in this age compiler and or AI generated documentation. And example would be if I call this method and this method is going to feed in a string to Java's URL class that does domain name resolution by opening sockets and could potentially block for two minutes, depending on retries. But something I should be able to know at the time when I do new URL and I feed in a string. And you might say, well, we need to invent an effect system. So people will know that a socket connection is being opened. All this things are happy. Do we? No, this is certainly need to change Java to know that. That's something that can be done by your IDE. Or any, you could tell you all these things. And the future of coding looks more like that, I think, where you're doing new URL in your feed in a string and then I'll sudden this panel pops up. And you've got like exploits. You've got how long this thing will take all the different ways it can fail, etc. And you can see exactly where it's going to where it's used throughout all your code base. You get tremendous information. That's, that's tooling. That's documentation. And I have never outside of a few niche areas. I've never heard a compelling set of reasons for why Facebook or Microsoft or capital one or Bank of America needs an effect system added to their business logic to help them write better, better, I don't even know exactly what problems it would, I can tell you minor ways in which they benefit. But I can't give you a solid business case for why any of these companies should have an effect system. I don't believe that business case exists. And I think that people are chasing something that is ultimately outside of a few areas, and an example would be a weight-a-sync promise in TypeScript, right? Because effect has a much better solution for asynchronous and concurrency than JavaScript the language has baked into it. Outside of a few niche areas like that, I don't see a business case. I've never seen one for effect systems, especially fine-grained effect systems. And some of the legitimate problems that they solve are actually solved in other ways, right? You're comparing effect systems like an effect system that tracks fine-grained effects is really solving a problem that modules solve. Or classes solve in other programming languages. If you really think about what's going on here and what benefits in my getting, you can replicate these same or potentially even better benefits, bigger set of benefits, by using modules, or by using classes, which are a lightweight form of modules. You can replicate them in other ways, so there's competition, right? Even for the benefits they do have, there's competition. It's not clear that effect system is the best way to get us these relatively small benefits that in my opinion, the average company is not going to be interested in retraining or rewriting to obtain. But that's my own personal opinion I'd be interested in hearing your thoughts on it. I'm curious to hear your take on the amount of effect systems being released. Even Zio was aiming for a particular set of problems that I personally found very composable. And I was curious to understand what the motivation was for the effect system for. .. I mean, you have the most context on Zio, but obviously you have enough context on Cat's effect, for instance, because you wanted a different approach to your effect system and Qio has its own design philosophy and so on and so forth. They have to be solving some set of problems well and my question was, what do you think those problems are? The way that I see this and to give you some context, the way that I've used effect systems was for critical code paths, just to make sure that those things are correct. And just so I can trace what happened throughout that code path. I made a little... it's a defunct product for security, for authorization in the age of AI and to prove that you're a human. And it's defunct because it doesn't have a market, but the implementation of that was using an effect system to validate whether the full scope of authorization was given up to the point where I'd given people access to a critical resource. And that was a problem that the effect system solved correctly for me. That fit my mental model well. I was curious to hear your take on it. Reasoning, right? And I think that ultimately that's the most legitimate argument for the fringe benefits of effect systems is they help you reason about your software. And that's great. In Zio's case, the pains that I was tackling were asynchronicity, which everyone at that time was tackling, right? Things like task and scalazed. And then later, the IO was a component of scalazed streams, which became FS2 functional streams for Scala. Asynchronicity was always there. It was always an argument. Async is too hard, we needed data type to help us manage this complexity. And then what Zio did differently was concurrency. Like Zio was in an early version of Zio, it was the first one starting betting all of this concurrent machinery in there. And that's IO was on track to be released in a non-concurrent version because early maintainers like Daniel Spiwack were like concurrency doesn't belong in here. That should be done. That should be streams, right? He came out with a blog post saying that basically all concurrency should be done at the level of streams, not the level of the effect system. And Zio had a different take on that, which is no. Any concurrency that streams gets, it should be from the effect top. So it should be concurrency. It should be asynchronicity and concurrency. Why? Because concurrency is really hard. And you want to integrate it with a nice interruption model, cancellation model, async receptions, whatever you want to call this. So you can do compositional timeouts. And so you can do efficient races and efficient parallelism so that if one thing cancels, you can cancel other things. So it's all connected and you can't say, oh, we're going to have an async type and then we're going to build concurrency on top. Doesn't work. You need to do async and concurrency inside the same effect type. So that was Zio's argument for being is that asynchronous, these are nasty pain, concurrency is nasty pain. And you want something, you want a data type that helps you build async concurrent applications that are correct by construction. So we have to bake that stuff in. And then early on, Zio also decided, and I think this makes ton of sense, I would not change this, that error management in the presence of concurrency and asynchronousity becomes even more challenging. And so Zio decides to have special support for errors. So that triple of things, which later expanded to resources, you know, dependencies and resources in the current incarnation, was what drove the early evolution of Zio. We want to make asynchronously concurrency and error management, easy, reasonable, principled and tight. And I think if you look at all of that stuff, it's pretty compelling. It's a pretty compelling case for using an effect system. However, if you delete some of those links, like let's just say we delete tight errors, right? We delete error management. So we don't want compositional errors that are lossless and that maintain a distinction between expected errors and unexpected errors. I think that's a mistake, but if you were to not value that, then you chop off one of those legs. In a post-loom world, you chop off another one of those legs. Is there enough return on investment to justify using a library like CATSIO or YO or Zio, if concurrency is the main thing you turn to that library for? I'm not sure. Because the vast majority of programmers are not competent to write concurrent code. They don't understand that and they don't even see the value of that. Because all they do is implement their request handlers by adding an annotation to their methods that is wired up somehow in the background by a process they don't understand and will probably never need to understand. And they don't deal with concurrency. The most they'll ever want to do is to do something in the background, like uploading a file or downloading a file. That's the most they'll ever want to do. So if you take that mindset back to the effect systems and say, well, is there a mainstream business case, even for something like Zio or CATSIO, a form which there definitely is a business case, and you can see that in the adoption, right? These libraries are widely adopted in the Scala community. There's a business case there, obviously. Does that generalize? Is that mainstream? And the answer is no. It's just no because first off, if you delete those legs and many languages had to lead in them, but also like programmers, async is not a problem post-loom. async is not a problem in many languages. I think it's a problem on the JVM, but it's not a problem on the JVM anymore. Still a problem in Rust, but they took a different path. Okay, so chop off that leg. Air management, every language has its own thing that it wants you to do, and more or less you have to do that if you want to be mainstream. So chop off that leg, and now you're back to concurrency. Okay, well, there's something there. Is it enough to support an effects system? I'm not sure. I don't think so. I think that even though if you're a concurrent programmer, you really want something? Most people are not concurrent programmers that never will be, and the future is less concurrent programming, not more concurrent programming. Concurrent programming is something that your operating system guys will do, and your database guys will do, but it's not something your business programmer should be doing. And I understand they have to do it some points now. Okay, no concurrency, no asynchronous, no error management. What problems are they turning to an effect system to solve reasoning? Okay, well, that's not great, right? That's the same reason to learn category theory, help you reason about your software better, and we know how many people do that. People don't want to have to reason about their software. Rather than giving them tools like effects systems that help them reason about how long this is going to take to execute latency and remote versus local connection, etc. Whether or not they're leaking resources, they want quick fixes that enable them to not have to think about these things. And so even though there is a lot of interest in hyping effects system, I would challenge you to name like a single mainstream example of an effect system. I think effect comes closest to a mainstream effect system. And even effect does not mainstream within TypeScript, and even TypeScript is not made... right, there's enough debates over whether or not you should use effect in TypeScript. There's haters, there's lovers. I think you should use effect if you're in TypeScript. But there's big debate in TypeScript. TypeScript is not even mainstream if you consider the larger JavaScript community because that community is, I don't know, 50 times bigger than the TypeScript community. Right, so, and that's the most mainstream effect system that exists right now. You could count Java's exceptions, type exceptions is an example of a special purpose effect system that was not successful. I just don't see, there's lots of hype, there's lots of effect systems, there's lots of programming languages with effect systems like unison and HOGA and so forth. But I don't see any examples of these crossing into mainstream except for effect TS and that's come closest. And there's good reasons why that makes sense in the JavaScript TypeScript ecosystem. Namely, the three legs that JavaScript or sorry that Zio stands on, which are concurrency, error management, asynchronicity. And without those three legs, I don't know if you can have anything approaching a mainstream effect system. Although I would be happy to be proven wrong. This is one of these cases where like if I'm wrong and we get an effect system in a mainstream language, then I will be delighted. Why? Because I actually like to reason about my software. I like to see things in type signatures, but I just don't see a business case for that. That's an interesting take and I am certainly curious where the effect systems will land. It's certainly appealing to a bunch of developers, including myself because once I've learned to think in terms of effects and watch method signatures and understand what they mean. I could be quite maybe counterintuitively more productive because I could write less code that did more just by just by using the right bricks with the right guarantees because I knew them well. There's definitely a learning curve to them and that's probably going to be, in my opinion, the main hurdle against their mainstream adoption because there's certainly conceptual frameworks that you absolutely need to understand before you can use effect systems well. So that's definitely a bit of effort on the developer part to overcome in order to be able to use an effect system well. But I was curious to hear your take on it. I don't know if you see that. There's an interesting take in the effect to yes community, which is that, and I've heard it before, by the way, I've heard it before outside this context, but like that AI favors effect systems. Why? Because effect systems make your code more maintainable, right? They give you more feedback at compile time and AI agents can deal with that feedback. They thrive on structure, man. Yeah, sure. So the argument is that even though it's like more boilerplady, you're not writing the code, right? And it's the AI who ends up benefiting from the code, right? Because they can find all these problems and fix them at compile time. And it remains to be seen if that argument is correct, but I think it's an interesting argument and I would be happy if that ends up proving correct. People made the same argument for Haskell, right? They said, Hey, eyes will like Haskell more and they'll generate better Haskell code and more people will use Haskell because you can prove more things that compile time. So far that has not translated into Haskell adoption. So I'm hesitant to say that's a winning argument because it didn't work in the case of Haskell. Maybe it will work at some point, but it's not working now as far as I can see there's less Haskell adoption now than ever before. And there's more gravitating towards the things that the AM models have been trained on, which is JavaScript and Python and stuff like that, rather gravitating towards the statically type programming languages. But again, I can see that argument and it might be right and time will tell. And if it is right, then maybe we'll see that little success in TypeScript replicated to other languages, which would be really interesting. And you know, by the way, that effect systems are winning when Oracle adds one to Java. Like that's the sign they want because Oracle at least some people in whoever's working on the Java language itself inside Oracle, they really are paying attention to things. And they really are tackling hard problems and solving them in a great way. And so that's why you see like, you know, value classes and better garbage collection and virtual threads and all this really amazing innovative stuff because there is some high competence in certain teams working on the Java language. And if they ever decide ratting the infectious to Java, well, you know it's one. I mean, that's not the only way to see that it's one, but obviously if Java were to do that, if they were to steal any of these ideas and put them in Java, you would know that effect systems at one. This is an interesting argument because Java has at least in recent years stolen many features that made Scala successful early in the day and maybe 15 years earlier than Java. And now that we see effect systems becoming mainstream within the niche communities like in Scala for example, because a lot of Scala code bases are written with or in effect style in hand with the cats effect or Zio or soon to be Kio and so on and so forth. I'm wondering whether this is going to be the case with Java 15 years down the line. And maybe we're at the stage where innovation is taking place and Java will adopt whatever is most successful from the offer of effect systems that we have at our disposal. This is probably remains to be seen. They're all trying it out, right? And it's like survival of the fittest. And if something survives and ends up proving itself over some period of time, it's like pattern matching. How long did it take Java to add that? It had to be proven. Yeah, in a few cases and people had to start leaving Java for pattern matching in Kotlin and C sharp and Scala. And then okay, Java's like, well, I guess pattern match is safe, right? We can finally add this. After 60 years of pattern matching being available in some programming language or another Java decided, yeah, we can add it safe. It's safe to add pattern match. He's not going away. Yeah. John, I want to be respectful of your time, but I do want to ask about one more topic if you have more time. I wanted to ask about your speaking abilities and how you do conference talks. You have historically created a variety of conference talks on a variety of subjects very different and with a high degree of And I wanted to ask about your process for creating conference talks. So what's your process while creating conference talks and generating ideas that send a good message, good takeaways and good ideas and good food for thought for the audience? I think that's a great question. And I've... I think been helped by my experience mentoring people to be conference speakers. I've worked with a lot of developers over the years, mentoring them to be able to give their first talk. And in some cases, their second, third talk. And so I've been able to peer inside their head and... get inside feedback on how they think about things. And so I know some of the areas that people get tripped up on. And I would say first off, when you're thinking about doing a conference talk, well, first off, you should commit to it. You should do it. It doesn't matter who you are, but you have something interesting to say. And it doesn't necessarily even need to be a conference talk in this day and age. It could be a local meetup group. If your city still has meetup groups, or it could be a video that you post on LinkedIn, or it could be a video you post on user. It could be any... everyone should work on their skill in communicating. And not just because that's useful, like in any possible career you could ever imagine being a better communicator can only help you. Whether it's communicating to your colleagues, or communicating to your boss, or communicating to the people who report to you. Or right, even inside your family, communicating to your parents, or your significant other, or your children, communication. No one ever complained because their communication skills were too good. Whatever had any life difficulty because they were too good a communicator. So, public speaking is its own art form and its own way of communicating. and it's going to help you in your career and probably in your personal life as well. So do it. No matter what, like, commit to doing it. It's useful for everyone and everyone can give a talk and everyone has something useful to say. Now, what's the most important thing? Well, the most important thing for giving a talk is making sure that it's valuable for its intended audience. And you have to start, you have to put yourself in another person's shoes and you have to think in terms of what am I going to get out of watching this talk? I am going to invest an hour of my time, potentially, in watching this talk. What am I going to get out of it? Like you have to be ruthless in the way you think about that. Because time is our most precious asset. You can only spend it once. And it's continuously running out. Right? And you're asking someone, by giving a talk, you're asking someone to give away an hour of their life. Why? You have to answer that question. Why are they giving away an hour of their life? And for the types of talks that we do, often the answer is, because this is going to make you a better develop. Okay? And that's not a bad answer. That's a good answer. Right? At least you're starting to think in terms of whatever the viewer of the talk will receive in exchange for giving away this hour of their time. But you need to be more specific than that. How are they going to become a better developer? Are they going to be learning an API? That helps them solve a problem at work? Okay, well, that's one type of answer. And that's a valid answer, by the way. But you need to do more work. Because it is quite possible. The API you intend on talking about is not interesting to them. Right? Or it could be that they don't need to learn to use that API. Because that's not the type of API that a typical developer needs to use. Maybe that's an API for library authors. In which case you're giving a talk for library authors, that's a small market. So you need to know your audience first. You need to know your audience. Who are you giving us talk for? And you need to understand very clearly what value you're going to be providing. Yeah. And by the way, you still have a tremendous amount of flexibility with that. So some beginner mistake that I've seen is people want to give a talk on a project they did. And they're all excited about it. Right? And they think it's great and wonderful. But they're not thinking about it from the perspective of, okay, well, no one is working in this domain. Right? No one's going to understand all the terminology you're using. All this is domain specific jargon. Also, the specific techniques you used here and the code that you wrote, no one's ever going to need that code again. In all of human history, right? You wrote that code one time for this specific esoteric niche problem. And no one's ever going to need to write that code again. So, even if you know your audience well, you need to find something in that topic in what you want to talk about that is going to be useful to members of that audience in some way. And that can mean instead of giving a talk, instead of making the theme of your talk, this esoteric code you wrote in this domain, you're going to focus on how you needed to do things in this specific way so that you could cut latency from 400 milliseconds to 40 milliseconds. It's something like that. Something that's more mainstream. Like, look, you want to give a talk on this area or on this library on this programming language or whatever it might happen to be, look for something in there that is going to help most people who are in the audience for that talk. And that's still, there's a lot of flexibility. You can still, like let's say you're speaking about unison. Okay, unison is a wonderful project, but it's also tricky to give a talk on unison to anyone outside the PLT community. Why? Because what are the actionable takeaways? Why would someone attend this talk? What are they going to get out of it? But there's still things in unison, right? You can grab onto that are going to help people in their day job writing Java code, but those are the things that you need to focus on. So getting the topic right is very important and understanding how and why a developer is going to give up their time to attend your talk is very important. And you should always be focused on creating value for your audience. And in most cases, that value is going to be educational. So you need to make sure that people take out of that enough practical stuff that they can take it back to their day job. However, not in all cases. Okay, there's two other ways that you as a conference speaker can give value. And one is inspiration. Okay, and that can be a component of almost every talk. You can inspire people to care about software engineering. If they see your passion, you might inspire passion in them. They might be bored out of their mind with their nine to five programming job writing Java for the past 20 years using spring. And they see your talk and they're like, wow, this is amazing. I'm excited about software engineering again. So inspiration is a perk and it is value. And you can write a talk that has no educational content. It's purely inspirational and that can still be successful, but it still does provide value for your audience members. And then the final one is entertainment. And a talk can just be funny. I've listened to some talks and I don't even remember what the technical content was about, but they were plenty funny. And I was entertained. And you know, I would watch them for the same reason that I would watch a show on Netflix just to be entertained. So education, you're upskilling your audience, inspiration, you're motivating them. And then entertainment, you're just giving them a good time. But understanding which of these three and what combination, because you know, I think a really good talk has elements from all of these. The best talks that will stay in the test of time, they teach you something, but also they inspire you. And there's somewhat entertaining. And so finding out what that balance is will help you choose not just the topic, but also what you choose to emphasize and how you choose to present it in that topic. And that gets you the talk abstract, basically. I mean, there's more to it, but at least you have what you're talking about. And from there, there's a whole process I use to take that high level idea into something that you can ultimately present and have a good experience and hopefully get people excited about to see on video after it comes out. Nice. I wanted to also ask about your speaking style, because you strike me as an articulate speaker, even with things that you haven't prepared. I mean, your conference talks look in terms of your speaking fluency and the pauses that you make. Similar to what we're doing right now, you strike me as a very articulate speaker. I mean, I've asked you questions that you haven't seen. I mean, you haven't seen my notes or the questions that I've prepared for this conversation, yet your message, at least for me as the listener, was very fluent. And I'm wondering if you've done any practice for this sort of thing, or if you have any process for how to improve that skill. Yeah, I do. So I would say for the typical conference talk, the most important thing that a speaker can do is to know the material very well, because if you're not intimately familiar with every single thing that you plan on speaking with, then it's just going to lead to problems down the road. So be extremely familiar with that source material. And if you are, and people are generally familiar about something in their life. So if you ask them about, you know, their Chevy, their 62 Chevy or whatever, and they're passionate about that, they can go on for an hour talking about all of this fascinating stuff related to that particular make and model and what they've done, their vehicle and whatnot. And there's never a lack of content there because they know it so well. And part of the process of preparing for a talk is to study this much. Right? You can't see my hands, but like study this much for a talk that's going to give you this much. And it's like that iceberg thing where there's so much and there's so many ideas swirling around and so much extra content. And you're never going to say all of it. You're only going to ever say a fraction of it. But because it's all sitting there, you have the context for everything. And everything you say is going to be well informed by the amount of information that you've already placed into your brain. So that helps tremendously is just knowing the subject matter well. And then the next tip that I have is understand the flow. Well, first off, every presentation, every talk has a story. And if you want a good talk, you have to focus on the high level structure of the story that you're telling. Right? You need a story arc. If you want us to be compelling, you have to have a story arc. And you need to fill in. Yes, you need all of this stuff. And it's drama. It's stuff you might pick up and draw a class. And it doesn't change the fact that it's a technical talk. It's still the same thing. It's just, you know, different terminology. And you kind of have to, you know, squint your eyes in order to see it. But there's a story arc there and you need that story arc. But let's ignore all the stuff about structure and just say, how can you be more fluid when you give the talk? Well, obviously, knowing the subject well. But then understanding the flow extremely well. And what I ask people to do is to rehearse their presentation. Obviously, they should talk out loud and they should talk through the whole thing. But then they should be able to, on every single slide, they should know what the slide is coming after that slide. They should be able to go to the end and always know what the next slide is. And they should even, if they really want to prepare, be able to go backwards and know what the slide is coming before the current one. And what this does is it creates in inside the speaker's mind a skeleton. Right? And then what comes over the skeleton? Well, that's the skin. That's the drapery. And it folds over the skeleton. But if you have the skeleton, then your talk will have a structure. And at every point there's going to be an arrow that is leading people down the next path. And that's going to allow people to keep track of where you are, which is going to keep them engaged. If people don't know where you are, which means they don't know where they came from and where you're going, then you're going to lose them. No matter if you're a good speaker, you're going to lose them. So people need to have this sense of progress and momentum we're going over here. And then we're going to come back over here. And now we're heading down here. They need that. And for you as somewhat, you know, beginner speaker, let's just say I'm coaching the beginner speaker, I would say you need to understand and have that structure so firmly etched into your brain that when you go to give the talk, you know where you are. And that's going to be reflected. If you know where you are and you know what you're talking about, you really know your stuff, then you cannot fail to communicate that to the audience. They're going to know where you are. And they're going to know that you know yourself. And so those are the two things I would say if you have your structure down, if you have your story arc, if you have your abstract, if you have like detention, you need tension, you need excitement, you need some sort of why. If you have all of that marketing stuff down and the structure in the content is good, then if you want to be a fluid speaker, know your content well and know the structure of your own talk very well. And that's going to help tremendously. And then there's other small tips that I give just to help them create a positive impression and one is being comfortable with silence. Don't think you need to fill everything with filler words. It's okay to just take a pause. And sometimes I'll pause purposely. Exactly. Intentional pause. Vocal variety. Like many beginner speakers just deliver it in a monotone. And sometimes that's because they tried to memorize it, which is never a good idea. Almost never a good idea. But like there should be variety in your intonation. You should vary your pitch. You should go up, you should go down. You should use your full vocal range because it makes it so much more engaging. The pauses in the vocal variety can just make something a lot more dynamic that might be dry and boring. But if you have the right intonations, if you have the right animations, if you are excited about this and you allow that to be reflected in your voice, then you can keep people engaged even if the content is somewhat dry. I took notes. Not for you. You're already an accomplished speaker, but for those of you. I always take notes, buddy. So I have given my fair share of conference talks, but there's always room for improvement. And I'm certainly looking for ways to improve my speaking abilities and my ability to deliver complex ideas in a clear and concise way. Because this is my main objective. I am a teacher. Sometimes, like 2% entertaining and an overarching arc of inspiration if the subject that I'm teaching is particularly interesting and inspiring for my audience. Nonetheless, I am looking for ways to improve and make an impact to the best degree that I can. So, yeah, I am taking notes as should the viewers and the listeners of this conversation. John, it's been a blast. I had so much fun to, in a half hours, flew by for me. Is there anything that you would like to share with my audience maybe a thought, a quip, or anything that comes to mind? What might that be before we wrap up? I would share this that I've been writing software for a long time. And I've even been doing talks and open source development and starting companies for a long time. And there is, it doesn't matter how much I do this. There is always more to learn. And that's the story of life is like learning and improving ourselves. And improving ourselves not just professionally, but personally like there's so many ways morally. There's so many ways that we can and should be improving ourselves. And I can be intimidating, but also it's exciting because it means there's never a reason to stagnant. We never need to sit there doing the same thing day after day, not learning, not advancing. There's always room to grow. And sometimes that means making ourselves uncomfortable. We go to the gym, we work out, right? We get on the cardio machines. Not very fun. It's the worst thing in the world. There's nothing worse than the cardio machine for me personally. Or lifting weights or whatever it is, watching a video on YouTube. Taking one of the rock, the JVM courses, contributing to a new open source project. Learning to put on your business hat. Learning to use one of these new fangled AI tools, coding agents, what's that? You know, wrestling with that. Like there's so much stuff to learn. And it's not stopping. And despite the fact that I've been writing software for many, many decades at this point, I am always learning things about writing software. And I'm always learning things about communicating. And I'm always learning things about building products that people actually want. And it's intimidating. It's uncomfortable. But it's exciting. And it means that it doesn't matter how old you are. Like if you're as old as me or even older, like there's stuff that's waiting to be discovered by you. You get to discover that. And it's part of your journey. And it's... I think that should be motivating. And I would like to leave your viewers with that idea that like you are exploring the final frontier space or the old West or whatever. You were discovering things that you have never seen before. Doesn't matter how long you've been at this. You will always be discovering. If you want to, you will always be discovering and learning. And that part of process is one of the most significant aspects to being alive and being a human that I think we can participate in and experience and benefit from. It's that constant sense of discovery and learning and migrating. And we might regress in some aspects. I can't run as fast as I used to. But we can make progress in other aspects. It doesn't matter our age. It doesn't matter what we've learned. There's always something new we can learn tomorrow. And there's always some way we can improve ourselves. And that should be very motivating and inspiring for people, I think. Well, this is the best thought to leave our audience with. John, it's been a pleasure. Where can people reach out? Where are you most active? And we can leave it at that. So I'm on LinkedIn. I'm happy to connect with any developer or LinkedIn if they want to stay in touch. And I also post there quite frequently. I'm also on X at JD goes. And I'm also on blue sky. Also at JD goes. And I post there once in a while. But mostly on LinkedIn and X these days. Amazing. Thank you so much for making that time. It's been so much fun. And for everybody listening, I'm going to leave links to the relevant technologies and topics that we've discussed. In the description of this video. And until next time, thank you for listening. Thanks, John. Thank you.